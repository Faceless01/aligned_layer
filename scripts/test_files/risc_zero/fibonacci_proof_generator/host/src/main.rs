// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{FIBONACCI_ELF, FIBONACCI_ID};
use risc0_zkvm::{default_prover, get_version, ExecutorEnv};

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    // An executor environment describes the configurations for the zkVM
    // including program inputs.
    // An default ExecutorEnv can be created like so:
    // `let env = ExecutorEnv::builder().build().unwrap();`
    // However, this `env` does not have any inputs.
    //
    // To add guest input to the executor environment, use
    // ExecutorEnvBuilder::write().
    // To access this method, you'll need to use ExecutorEnv::builder(), which
    // creates an ExecutorEnvBuilder. When you're done adding input, call
    // ExecutorEnvBuilder::build().

    // For example:
    let input: u32 = 500;
    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    // Produce a receipt by proving the specified ELF binary.
    let receipt = prover.prove(env, FIBONACCI_ELF).unwrap().receipt;

    // Retrieve receipt journal here.
    let vars: (u32, u32) = receipt.journal.decode().unwrap();

    let (a, b) = vars;
    //https://github.com/risc0/risc0/tree/v2.1.0
    println!("a: {}", a);
    println!("b: {}", b);

    let verification_result = receipt.verify(FIBONACCI_ID).is_ok();

    println!("Verification result: {}", verification_result);

    let version_str = get_version()
        .expect("Failed to get the risc zero version")
        .to_string()
        .replace(".", "_");

    let serialized = bincode::serialize(&receipt.inner).expect("Failed to serialize the receipt");

    let proof_file_path = format!("risc_zero_fibonacci_{}.proof", version_str);
    let pub_input_file_path = format!("risc_zero_fibonacci_{}.pub", version_str);
    let fibonacci_id_file_path = format!("fibonacci_id_{}.bin", version_str);

    std::fs::write(proof_file_path, serialized).expect("Failed to write proof file");

    std::fs::write(fibonacci_id_file_path, convert(&FIBONACCI_ID))
        .expect("Failed to write fibonacci_id file");

    std::fs::write(pub_input_file_path, receipt.journal.bytes)
        .expect("Failed to write pub_input file");
}

pub fn convert(data: &[u32; 8]) -> [u8; 32] {
    let mut res = [0; 32];
    for i in 0..8 {
        res[4 * i..4 * (i + 1)].copy_from_slice(&data[i].to_le_bytes());
    }
    res
}
